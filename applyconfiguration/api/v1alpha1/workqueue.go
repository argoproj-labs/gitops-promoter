/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by controller-gen-v0.20. DO NOT EDIT.

package v1alpha1

import (
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// WorkQueueApplyConfiguration represents a declarative configuration of the WorkQueue type for use
// with apply.
//
// WorkQueue defines the work queue configuration for a controller.
//
// This configuration directly correlates to parameters used with Kubernetes client-go work queues.
// It controls how frequently resources are reconciled, how many reconciliations can run concurrently,
// and how rate limiting is applied to prevent overwhelming external systems.
//
// See https://pkg.go.dev/k8s.io/client-go/util/workqueue for implementation details.
type WorkQueueApplyConfiguration struct {
	// RequeueDuration specifies how frequently resources should be requeued for automatic reconciliation.
	// This creates a periodic reconciliation loop that ensures the desired state is maintained even
	// without external triggers. Format follows Go's time.Duration syntax (e.g., "5m" for 5 minutes).
	RequeueDuration *v1.Duration `json:"requeueDuration,omitempty"`
	// MaxConcurrentReconciles defines the maximum number of concurrent reconcile operations
	// that can run for this controller. Higher values increase throughput but consume more
	// resources. Must be at least 1.
	MaxConcurrentReconciles *int `json:"maxConcurrentReconciles,omitempty"`
	// RateLimiter defines the rate limiting strategy for the controller's work queue.
	// Rate limiting controls how quickly failed reconciliations are retried and helps
	// prevent overwhelming external APIs or systems.
	RateLimiter *RateLimiterApplyConfiguration `json:"rateLimiter,omitempty"`
}

// WorkQueueApplyConfiguration constructs a declarative configuration of the WorkQueue type for use with
// apply.
func WorkQueue() *WorkQueueApplyConfiguration {
	return &WorkQueueApplyConfiguration{}
}

// WithRequeueDuration sets the RequeueDuration field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the RequeueDuration field is set to the value of the last call.
func (b *WorkQueueApplyConfiguration) WithRequeueDuration(value v1.Duration) *WorkQueueApplyConfiguration {
	b.RequeueDuration = &value
	return b
}

// WithMaxConcurrentReconciles sets the MaxConcurrentReconciles field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MaxConcurrentReconciles field is set to the value of the last call.
func (b *WorkQueueApplyConfiguration) WithMaxConcurrentReconciles(value int) *WorkQueueApplyConfiguration {
	b.MaxConcurrentReconciles = &value
	return b
}

// WithRateLimiter sets the RateLimiter field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the RateLimiter field is set to the value of the last call.
func (b *WorkQueueApplyConfiguration) WithRateLimiter(value *RateLimiterApplyConfiguration) *WorkQueueApplyConfiguration {
	b.RateLimiter = value
	return b
}
