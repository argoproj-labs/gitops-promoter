/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by controller-gen-v0.20. DO NOT EDIT.

package v1alpha1

// RateLimiterApplyConfiguration represents a declarative configuration of the RateLimiter type for use
// with apply.
//
// RateLimiter defines the rate limiting configuration for controllers.
//
// This type supports both simple rate limiting strategies (FastSlow, ExponentialFailure, Bucket)
// and composite strategies using MaxOf, which returns the maximum delay from multiple rate limiters.
// This allows for sophisticated rate limiting behavior that combines multiple strategies.
//
// Exactly one of the rate limiter types or MaxOf must be specified.
//
// See https://pkg.go.dev/k8s.io/client-go/util/workqueue for rate limiter implementation details.
type RateLimiterApplyConfiguration struct {
	// RateLimiterTypes can be one of: FastSlow, ExponentialFailure, or Bucket.
	RateLimiterTypesApplyConfiguration `json:",inline"`
	// MaxOf allows combining multiple rate limiters, where the maximum delay from all
	// limiters is used. This enables sophisticated rate limiting that respects multiple
	// constraints simultaneously (e.g., both per-item exponential backoff and global rate limits).
	MaxOf []RateLimiterTypesApplyConfiguration `json:"maxOf,omitempty"`
}

// RateLimiterApplyConfiguration constructs a declarative configuration of the RateLimiter type for use with
// apply.
func RateLimiter() *RateLimiterApplyConfiguration {
	return &RateLimiterApplyConfiguration{}
}

// WithFastSlow sets the FastSlow field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FastSlow field is set to the value of the last call.
func (b *RateLimiterApplyConfiguration) WithFastSlow(value *FastSlowApplyConfiguration) *RateLimiterApplyConfiguration {
	b.RateLimiterTypesApplyConfiguration.FastSlow = value
	return b
}

// WithExponentialFailure sets the ExponentialFailure field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ExponentialFailure field is set to the value of the last call.
func (b *RateLimiterApplyConfiguration) WithExponentialFailure(value *ExponentialFailureApplyConfiguration) *RateLimiterApplyConfiguration {
	b.RateLimiterTypesApplyConfiguration.ExponentialFailure = value
	return b
}

// WithBucket sets the Bucket field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Bucket field is set to the value of the last call.
func (b *RateLimiterApplyConfiguration) WithBucket(value *BucketApplyConfiguration) *RateLimiterApplyConfiguration {
	b.RateLimiterTypesApplyConfiguration.Bucket = value
	return b
}

// WithMaxOf adds the given value to the MaxOf field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the MaxOf field.
func (b *RateLimiterApplyConfiguration) WithMaxOf(values ...*RateLimiterTypesApplyConfiguration) *RateLimiterApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithMaxOf")
		}
		b.MaxOf = append(b.MaxOf, *values[i])
	}
	return b
}
